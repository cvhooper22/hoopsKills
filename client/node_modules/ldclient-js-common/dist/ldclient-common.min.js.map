{"version":3,"file":"ldclient-common.min.js","sources":["../src/errors.js","../node_modules/base64-js/index.js","../node_modules/fast-deep-equal/index.js","../src/utils.js","../src/EventSender.js","../src/UserFilter.js","../src/messages.js","../src/EventProcessor.js","../src/EventSummarizer.js","../src/EventEmitter.js","../src/Requestor.js","../src/promiseCoalescer.js","../node_modules/uuid/lib/bytesToUuid.js","../node_modules/uuid/lib/rng-browser.js","../node_modules/uuid/v1.js","../src/UserValidator.js","../src/consoleLogger.js","../src/index.js","../src/configuration.js","../src/Stream.js","../src/Identity.js","../src/Store.js"],"sourcesContent":["function createCustomError(name) {\n  function CustomError(message, code) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.code = code;\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.name = name;\n  CustomError.prototype.constructor = CustomError;\n\n  return CustomError;\n}\n\nexport const LDUnexpectedResponseError = createCustomError('LaunchDarklyUnexpectedResponseError');\nexport const LDInvalidEnvironmentIdError = createCustomError('LaunchDarklyInvalidEnvironmentIdError');\nexport const LDInvalidUserError = createCustomError('LaunchDarklyInvalidUserError');\nexport const LDInvalidEventKeyError = createCustomError('LaunchDarklyInvalidEventKeyError');\nexport const LDInvalidArgumentError = createCustomError('LaunchDarklyInvalidArgumentError');\nexport const LDFlagFetchError = createCustomError('LaunchDarklyFlagFetchError');\n\nexport function isHttpErrorRecoverable(status) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","import * as base64 from 'base64-js';\nimport fastDeepEqual from 'fast-deep-equal';\n\nconst userAttrsToStringify = ['key', 'secondary', 'ip', 'country', 'email', 'firstName', 'lastName', 'avatar', 'name'];\n\n// See http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\nexport function btoa(s) {\n  const escaped = unescape(encodeURIComponent(s));\n  return base64.fromByteArray(stringToBytes(escaped));\n}\n\nfunction stringToBytes(s) {\n  const b = [];\n  for (let i = 0; i < s.length; i++) {\n    b.push(s.charCodeAt(i));\n  }\n  return b;\n}\n\nexport function base64URLEncode(s) {\n  return (\n    btoa(s)\n      // eslint-disable-next-line\n      .replace(/=/g, '')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n  );\n}\n\nexport function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function deepEquals(a, b) {\n  return fastDeepEqual(a, b);\n}\n\n// Events emitted in LDClient's initialize method will happen before the consumer\n// can register a listener, so defer them to next tick.\nexport function onNextTick(cb) {\n  setTimeout(cb, 0);\n}\n\n/**\n * Wrap a promise to invoke an optional callback upon resolution or rejection.\n *\n * This function assumes the callback follows the Node.js callback type: (err, value) => void\n *\n * If a callback is provided:\n *   - if the promise is resolved, invoke the callback with (null, value)\n *   - if the promise is rejected, invoke the callback with (error, null)\n *\n * @param {Promise<any>} promise\n * @param {Function} callback\n * @returns Promise<any> | undefined\n */\nexport function wrapPromiseCallback(promise, callback) {\n  const ret = promise.then(\n    value => {\n      if (callback) {\n        setTimeout(() => {\n          callback(null, value);\n        }, 0);\n      }\n      return value;\n    },\n    error => {\n      if (callback) {\n        setTimeout(() => {\n          callback(error, null);\n        }, 0);\n      } else {\n        return Promise.reject(error);\n      }\n    }\n  );\n\n  return !callback ? ret : undefined;\n}\n\n/**\n * Takes a map of flag keys to values, and returns the more verbose structure used by the\n * client stream.\n */\nexport function transformValuesToVersionedValues(flags) {\n  const ret = {};\n  for (const key in flags) {\n    if (flags.hasOwnProperty(key)) {\n      ret[key] = { value: flags[key], version: 0 };\n    }\n  }\n  return ret;\n}\n\n/**\n * Converts the internal flag state map to a simple map of flag keys to values.\n */\nexport function transformVersionedValuesToValues(flagsState) {\n  const ret = {};\n  for (const key in flagsState) {\n    if (flagsState.hasOwnProperty(key)) {\n      ret[key] = flagsState[key].value;\n    }\n  }\n  return ret;\n}\n\n/**\n * Returns an array of event groups each of which can be safely URL-encoded\n * without hitting the safe maximum URL length of certain browsers.\n *\n * @param {number} maxLength maximum URL length targeted\n * @param {Array[Object}]} events queue of events to divide\n * @returns Array[Array[Object]]\n */\nexport function chunkUserEventsForUrl(maxLength, events) {\n  const allEvents = events.slice(0);\n  const allChunks = [];\n  let remainingSpace = maxLength;\n  let chunk;\n\n  while (allEvents.length > 0) {\n    chunk = [];\n\n    while (remainingSpace > 0) {\n      const event = allEvents.shift();\n      if (!event) {\n        break;\n      }\n      remainingSpace = remainingSpace - base64URLEncode(JSON.stringify(event)).length;\n      // If we are over the max size, put this one back on the queue\n      // to try in the next round, unless this event alone is larger\n      // than the limit, in which case, screw it, and try it anyway.\n      if (remainingSpace < 0 && chunk.length > 0) {\n        allEvents.unshift(event);\n      } else {\n        chunk.push(event);\n      }\n    }\n\n    remainingSpace = maxLength;\n    allChunks.push(chunk);\n  }\n\n  return allChunks;\n}\n\nexport function getLDUserAgentString(platform) {\n  const version = platform.version || VERSION;\n  return platform.userAgent + '/' + version;\n}\n\nexport function getLDHeaders(platform) {\n  return {\n    'X-LaunchDarkly-User-Agent': getLDUserAgentString(platform),\n  };\n}\n\nexport function extend(...objects) {\n  return objects.reduce((acc, obj) => ({ ...acc, ...obj }), {});\n}\n\nexport function sanitizeUser(user) {\n  if (!user) {\n    return user;\n  }\n  let newUser;\n  for (const i in userAttrsToStringify) {\n    const attr = userAttrsToStringify[i];\n    const value = user[attr];\n    if (value !== undefined && typeof value !== 'string') {\n      newUser = newUser || Object.assign({}, user);\n      newUser[attr] = String(value);\n    }\n  }\n  return newUser || user;\n}\n","import * as errors from './errors';\nimport * as utils from './utils';\n\nconst MAX_URL_LENGTH = 2000;\n\nexport default function EventSender(platform, eventsUrl, environmentId, imageCreator) {\n  const postUrl = eventsUrl + '/events/bulk/' + environmentId;\n  const imageUrl = eventsUrl + '/a/' + environmentId + '.gif';\n  const sender = {};\n\n  function loadUrlUsingImage(src) {\n    const img = new window.Image();\n    img.src = src;\n  }\n\n  function getResponseInfo(result) {\n    const ret = { status: result.status };\n    const dateStr = result.header('date');\n    if (dateStr) {\n      const time = Date.parse(dateStr);\n      if (time) {\n        ret.serverTime = time;\n      }\n    }\n    return ret;\n  }\n\n  function sendChunk(events, usePost) {\n    const createImage = imageCreator || loadUrlUsingImage;\n    const jsonBody = JSON.stringify(events);\n\n    function doPostRequest(canRetry) {\n      const headers = utils.extend(\n        {\n          'Content-Type': 'application/json',\n          'X-LaunchDarkly-Event-Schema': '3',\n        },\n        utils.getLDHeaders(platform)\n      );\n      return platform\n        .httpRequest('POST', postUrl, headers, jsonBody)\n        .promise.then(result => {\n          if (!result) {\n            // This was a response from a fire-and-forget request, so we won't have a status.\n            return;\n          }\n          if (result.status >= 400 && errors.isHttpErrorRecoverable(result.status) && canRetry) {\n            return doPostRequest(false);\n          } else {\n            return getResponseInfo(result);\n          }\n        })\n        .catch(() => {\n          if (canRetry) {\n            return doPostRequest(false);\n          }\n          return Promise.reject();\n        });\n    }\n\n    if (usePost) {\n      return doPostRequest(true).catch(() => {});\n    } else {\n      const src = imageUrl + '?d=' + utils.base64URLEncode(jsonBody);\n      createImage(src);\n      return Promise.resolve();\n      // We do not specify an onload handler for the image because we don't want the client to wait around\n      // for the image to load - it won't provide a server response, there's nothing to be done.\n    }\n  }\n\n  sender.sendEvents = function(events) {\n    if (!platform.httpRequest) {\n      return Promise.resolve();\n    }\n    const canPost = platform.httpAllowsPost();\n    let chunks;\n    if (canPost) {\n      // no need to break up events into chunks if we can send a POST\n      chunks = [events];\n    } else {\n      chunks = utils.chunkUserEventsForUrl(MAX_URL_LENGTH - eventsUrl.length, events);\n    }\n    const results = [];\n    for (let i = 0; i < chunks.length; i++) {\n      results.push(sendChunk(chunks[i], canPost));\n    }\n    return Promise.all(results);\n  };\n\n  return sender;\n}\n","import * as utils from './utils';\n\n/**\n * The UserFilter object transforms user objects into objects suitable to be sent as JSON to\n * the server, hiding any private user attributes.\n *\n * @param {Object} the LaunchDarkly client configuration object\n **/\nexport default function UserFilter(config) {\n  const filter = {};\n  const allAttributesPrivate = config.allAttributesPrivate;\n  const privateAttributeNames = config.privateAttributeNames || [];\n  const ignoreAttrs = { key: true, custom: true, anonymous: true };\n  const allowedTopLevelAttrs = {\n    key: true,\n    secondary: true,\n    ip: true,\n    country: true,\n    email: true,\n    firstName: true,\n    lastName: true,\n    avatar: true,\n    name: true,\n    anonymous: true,\n    custom: true,\n  };\n\n  filter.filterUser = function(user) {\n    if (!user) {\n      return null;\n    }\n    const userPrivateAttrs = user.privateAttributeNames || [];\n\n    const isPrivateAttr = function(name) {\n      return (\n        !ignoreAttrs[name] &&\n        (allAttributesPrivate || userPrivateAttrs.indexOf(name) !== -1 || privateAttributeNames.indexOf(name) !== -1)\n      );\n    };\n    const filterAttrs = function(props, isAttributeAllowed) {\n      return Object.keys(props).reduce(\n        (acc, name) => {\n          const ret = acc;\n          if (isAttributeAllowed(name)) {\n            if (isPrivateAttr(name)) {\n              // add to hidden list\n              ret[1][name] = true;\n            } else {\n              ret[0][name] = props[name];\n            }\n          }\n          return ret;\n        },\n        [{}, {}]\n      );\n    };\n    const result = filterAttrs(user, key => allowedTopLevelAttrs[key]);\n    const filteredProps = result[0];\n    let removedAttrs = result[1];\n    if (user.custom) {\n      const customResult = filterAttrs(user.custom, () => true);\n      filteredProps.custom = customResult[0];\n      removedAttrs = utils.extend({}, removedAttrs, customResult[1]);\n    }\n    const removedAttrNames = Object.keys(removedAttrs);\n    if (removedAttrNames.length) {\n      removedAttrNames.sort();\n      filteredProps.privateAttrs = removedAttrNames;\n    }\n    return filteredProps;\n  };\n  return filter;\n}\n","import * as errors from './errors';\n\nexport const clientInitialized = function() {\n  return 'LaunchDarkly client initialized';\n};\n\nconst docLink =\n  ' Please see https://docs.launchdarkly.com/docs/js-sdk-reference#section-initializing-the-client for instructions on SDK initialization.';\n\nexport const clientNotReady = function() {\n  return 'LaunchDarkly client is not ready';\n};\n\nexport const eventWithoutUser = function() {\n  return 'Be sure to call `identify` in the LaunchDarkly client: http://docs.launchdarkly.com/docs/running-an-ab-test#include-the-client-side-snippet';\n};\n\nexport const invalidKey = function() {\n  return 'Event key must be a string';\n};\n\nexport const localStorageUnavailable = function() {\n  return 'localStorage is unavailable';\n};\n\nexport const localStorageUnavailableForUserId = function() {\n  return 'localStorage is unavailable, so anonymous user ID cannot be cached';\n};\n\nexport const networkError = e => 'network error' + (e ? ' (' + e + ')' : '');\n\nexport const unknownCustomEventKey = function(key) {\n  return 'Custom event \"' + key + '\" does not exist';\n};\n\nexport const environmentNotFound = function() {\n  return 'environment not found.' + docLink;\n};\n\nexport const environmentNotSpecified = function() {\n  return 'No environment specified.' + docLink;\n};\n\nexport const errorFetchingFlags = function(err) {\n  return 'Error fetching flag settings: ' + (err.message || err);\n};\n\nexport const userNotSpecified = function() {\n  return 'No user specified.' + docLink;\n};\n\nexport const invalidUser = function() {\n  return 'Invalid user specified.' + docLink;\n};\n\nexport const bootstrapOldFormat = function() {\n  return (\n    'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. ' +\n    'Events may not be sent correctly.' +\n    docLink\n  );\n};\n\nexport const bootstrapInvalid = function() {\n  return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';\n};\n\nexport const deprecated = function(oldName, newName) {\n  return '[LaunchDarkly] \"' + oldName + '\" is deprecated, please use \"' + newName + '\"';\n};\n\nexport const httpErrorMessage = function(status, context, retryMessage) {\n  return (\n    'Received error ' +\n    status +\n    (status === 401 ? ' (invalid SDK key)' : '') +\n    ' for ' +\n    context +\n    ' - ' +\n    (errors.isHttpErrorRecoverable(status) ? retryMessage : 'giving up permanently')\n  );\n};\n\nexport const httpUnavailable = function() {\n  return 'Cannot make HTTP requests in this environment.' + docLink;\n};\n\nexport const identifyDisabled = function() {\n  return 'identify() has no effect here; it must be called on the main client instance';\n};\n\nexport const debugPolling = function(url) {\n  return 'polling for feature flags at ' + url;\n};\n\nexport const debugStreamPing = function() {\n  return 'received ping message from stream';\n};\n\nexport const debugStreamPut = function() {\n  return 'received streaming update for all flags';\n};\n\nexport const debugStreamPatch = function(key) {\n  return 'received streaming update for flag \"' + key + '\"';\n};\n\nexport const debugStreamPatchIgnored = function(key) {\n  return 'received streaming update for flag \"' + key + '\" but ignored due to version check';\n};\n\nexport const debugStreamDelete = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\"';\n};\n\nexport const debugStreamDeleteIgnored = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\" but ignored due to version check';\n};\n\nexport const debugEnqueueingEvent = function(kind) {\n  return 'enqueueing \"' + kind + '\" event';\n};\n\nexport const debugPostingEvents = function(count) {\n  return 'sending ' + count + ' events';\n};\n","import EventSender from './EventSender';\nimport EventSummarizer from './EventSummarizer';\nimport UserFilter from './UserFilter';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function EventProcessor(platform, options, environmentId, logger, emitter = null, sender = null) {\n  const processor = {};\n  const eventSender = sender || EventSender(platform, options.eventsUrl, environmentId);\n  const summarizer = EventSummarizer();\n  const userFilter = UserFilter(options);\n  const inlineUsers = options.inlineUsersInEvents;\n  const samplingInterval = options.samplingInterval;\n  const flushInterval = options.flushInterval;\n  let queue = [];\n  let lastKnownPastTime = 0;\n  let disabled = false;\n  let flushTimer;\n\n  function shouldSampleEvent() {\n    return samplingInterval === 0 || Math.floor(Math.random() * samplingInterval) === 0;\n  }\n\n  function shouldDebugEvent(e) {\n    if (e.debugEventsUntilDate) {\n      // The \"last known past time\" comes from the last HTTP response we got from the server.\n      // In case the client's time is set wrong, at least we know that any expiration date\n      // earlier than that point is definitely in the past.  If there's any discrepancy, we\n      // want to err on the side of cutting off event debugging sooner.\n      return e.debugEventsUntilDate > lastKnownPastTime && e.debugEventsUntilDate > new Date().getTime();\n    }\n    return false;\n  }\n\n  // Transform an event from its internal format to the format we use when sending a payload.\n  function makeOutputEvent(e) {\n    const ret = utils.extend({}, e);\n    if (inlineUsers || e.kind === 'identify') {\n      // identify events always have an inline user\n      ret.user = userFilter.filterUser(e.user);\n    } else {\n      ret.userKey = e.user.key;\n      delete ret['user'];\n    }\n    if (e.kind === 'feature') {\n      delete ret['trackEvents'];\n      delete ret['debugEventsUntilDate'];\n    }\n    return ret;\n  }\n\n  processor.enqueue = function(event) {\n    if (disabled) {\n      return;\n    }\n    let addFullEvent = false;\n    let addDebugEvent = false;\n\n    // Add event to the summary counters if appropriate\n    summarizer.summarizeEvent(event);\n\n    // Decide whether to add the event to the payload. Feature events may be added twice, once for\n    // the event (if tracked) and once for debugging.\n    if (event.kind === 'feature') {\n      if (shouldSampleEvent()) {\n        addFullEvent = !!event.trackEvents;\n        addDebugEvent = shouldDebugEvent(event);\n      }\n    } else {\n      addFullEvent = shouldSampleEvent();\n    }\n\n    if (addFullEvent) {\n      queue.push(makeOutputEvent(event));\n    }\n    if (addDebugEvent) {\n      const debugEvent = utils.extend({}, event, { kind: 'debug' });\n      delete debugEvent['trackEvents'];\n      delete debugEvent['debugEventsUntilDate'];\n      delete debugEvent['variation'];\n      queue.push(debugEvent);\n    }\n  };\n\n  processor.flush = function() {\n    if (disabled) {\n      return Promise.resolve();\n    }\n    const eventsToSend = queue;\n    const summary = summarizer.getSummary();\n    summarizer.clearSummary();\n    if (summary) {\n      summary.kind = 'summary';\n      eventsToSend.push(summary);\n    }\n    if (eventsToSend.length === 0) {\n      return Promise.resolve();\n    }\n    queue = [];\n    logger.debug(messages.debugPostingEvents(eventsToSend.length));\n    return eventSender.sendEvents(eventsToSend).then(responseInfo => {\n      if (responseInfo) {\n        if (responseInfo.serverTime) {\n          lastKnownPastTime = responseInfo.serverTime;\n        }\n        if (!errors.isHttpErrorRecoverable(responseInfo.status)) {\n          disabled = true;\n        }\n        if (responseInfo.status >= 400) {\n          utils.onNextTick(() => {\n            emitter.maybeReportError(\n              new errors.LDUnexpectedResponseError(\n                messages.httpErrorMessage(responseInfo.status, 'event posting', 'some events were dropped')\n              )\n            );\n          });\n        }\n      }\n    });\n  };\n\n  processor.start = function() {\n    const flushTick = () => {\n      processor.flush();\n      flushTimer = setTimeout(flushTick, flushInterval);\n    };\n    flushTimer = setTimeout(flushTick, flushInterval);\n  };\n\n  processor.stop = function() {\n    clearTimeout(flushTimer);\n  };\n\n  return processor;\n}\n","export default function EventSummarizer() {\n  const es = {};\n\n  let startDate = 0,\n    endDate = 0,\n    counters = {};\n\n  es.summarizeEvent = function(event) {\n    if (event.kind === 'feature') {\n      const counterKey =\n        event.key +\n        ':' +\n        (event.variation !== null && event.variation !== undefined ? event.variation : '') +\n        ':' +\n        (event.version !== null && event.version !== undefined ? event.version : '');\n      const counterVal = counters[counterKey];\n      if (counterVal) {\n        counterVal.count = counterVal.count + 1;\n      } else {\n        counters[counterKey] = {\n          count: 1,\n          key: event.key,\n          variation: event.variation,\n          version: event.version,\n          value: event.value,\n          default: event.default,\n        };\n      }\n      if (startDate === 0 || event.creationDate < startDate) {\n        startDate = event.creationDate;\n      }\n      if (event.creationDate > endDate) {\n        endDate = event.creationDate;\n      }\n    }\n  };\n\n  es.getSummary = function() {\n    const flagsOut = {};\n    let empty = true;\n    for (const i in counters) {\n      const c = counters[i];\n      let flag = flagsOut[c.key];\n      if (!flag) {\n        flag = {\n          default: c.default,\n          counters: [],\n        };\n        flagsOut[c.key] = flag;\n      }\n      const counterOut = {\n        value: c.value,\n        count: c.count,\n      };\n      if (c.variation !== undefined && c.variation !== null) {\n        counterOut.variation = c.variation;\n      }\n      if (c.version) {\n        counterOut.version = c.version;\n      } else {\n        counterOut.unknown = true;\n      }\n      flag.counters.push(counterOut);\n      empty = false;\n    }\n    return empty\n      ? null\n      : {\n          startDate,\n          endDate,\n          features: flagsOut,\n        };\n  };\n\n  es.clearSummary = function() {\n    startDate = 0;\n    endDate = 0;\n    counters = {};\n  };\n\n  return es;\n}\n","export default function EventEmitter(logger) {\n  const emitter = {};\n  const events = {};\n\n  const listeningTo = event => !!events[event];\n\n  emitter.on = function(event, handler, context) {\n    events[event] = events[event] || [];\n    events[event] = events[event].concat({\n      handler: handler,\n      context: context,\n    });\n  };\n\n  emitter.off = function(event, handler, context) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      if (events[event][i].handler === handler && events[event][i].context === context) {\n        events[event] = events[event].slice(0, i).concat(events[event].slice(i + 1));\n      }\n    }\n  };\n\n  emitter.emit = function(event) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      events[event][i].handler.apply(events[event][i].context, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  emitter.getEvents = function() {\n    return Object.keys(events);\n  };\n\n  emitter.getEventListenerCount = function(event) {\n    return events[event] ? events[event].length : 0;\n  };\n\n  emitter.maybeReportError = function(error) {\n    if (!error) {\n      return;\n    }\n    if (listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      (logger || console).error(error.message);\n    }\n  };\n  return emitter;\n}\n","import * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport promiseCoalescer from './promiseCoalescer';\n\nconst json = 'application/json';\n\nfunction getResponseError(result) {\n  if (result.status === 404) {\n    return new errors.LDInvalidEnvironmentIdError(messages.environmentNotFound());\n  } else {\n    return new errors.LDFlagFetchError(messages.errorFetchingFlags(result.statusText || String(result.status)));\n  }\n}\n\nexport default function Requestor(platform, options, environment, logger) {\n  const baseUrl = options.baseUrl;\n  const useReport = options.useReport;\n  const withReasons = options.evaluationReasons;\n  const sendLDHeaders = options.sendLDHeaders;\n\n  const requestor = {};\n\n  const activeRequests = {}; // map of URLs to promiseCoalescers\n\n  function fetchJSON(endpoint, body) {\n    if (!platform.httpRequest) {\n      return new Promise((resolve, reject) => {\n        reject(new errors.LDFlagFetchError(messages.httpUnavailable()));\n      });\n    }\n\n    const method = body ? 'REPORT' : 'GET';\n    const headers = sendLDHeaders ? utils.getLDHeaders(platform) : {};\n    if (body) {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    let coalescer = activeRequests[endpoint];\n    if (!coalescer) {\n      coalescer = promiseCoalescer(() => {\n        // this will be called once there are no more active requests for the same endpoint\n        delete activeRequests[endpoint];\n      });\n      activeRequests[endpoint] = coalescer;\n    }\n\n    const req = platform.httpRequest(method, endpoint, headers, body);\n    const p = req.promise.then(\n      result => {\n        if (\n          result.status === 200 &&\n          result.header('content-type') &&\n          result.header('content-type').lastIndexOf(json) === 0\n        ) {\n          return JSON.parse(result.body);\n        } else {\n          return Promise.reject(getResponseError(result));\n        }\n      },\n      e => Promise.reject(new errors.LDFlagFetchError(messages.networkError(e)))\n    );\n    coalescer.addPromise(p, () => {\n      // this will be called if another request for the same endpoint supersedes this one\n      req.cancel && req.cancel();\n    });\n    return coalescer.resultPromise;\n  }\n\n  // Returns a Promise which will resolve with the parsed JSON response, or will be\n  // rejected if the request failed.\n  requestor.fetchFlagSettings = function(user, hash) {\n    let data;\n    let endpoint;\n    let query = '';\n    let body;\n\n    if (useReport) {\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/user'].join('');\n      body = JSON.stringify(user);\n    } else {\n      data = utils.base64URLEncode(JSON.stringify(user));\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/users/', data].join('');\n    }\n    if (hash) {\n      query = 'h=' + hash;\n    }\n    if (withReasons) {\n      query = query + (query ? '&' : '') + 'withReasons=true';\n    }\n    endpoint = endpoint + (query ? '?' : '') + query;\n    logger.debug(messages.debugPolling(endpoint));\n\n    return fetchJSON(endpoint, body);\n  };\n\n  // Returns a Promise which will resolve with the parsed JSON response, or will be\n  // rejected if the request failed.\n  requestor.fetchGoals = function() {\n    const endpoint = [baseUrl, '/sdk/goals/', environment].join('');\n    return fetchJSON(endpoint, null);\n  };\n\n  return requestor;\n}\n","// This function allows a series of Promises to be coalesced such that only the most recently\n// added one actually matters. For instance, if several HTTP requests are made to the same\n// endpoint and we want to ensure that whoever made each one always gets the latest data, each\n// can be passed to addPromise (on the same coalescer) and each caller can wait on the\n// coalescer.resultPromise; all three will then receive the result (or error) from the *last*\n// request, and the results of the first two will be discarded.\n//\n// The cancelFn callback, if present, will be called whenever an existing promise is being\n// discarded. This can be used for instance to abort an HTTP request that's now obsolete.\n//\n// The finallyFn callback, if present, is called on completion of the whole thing. This is\n// different from calling coalescer.resultPromise.finally() because it is executed before any\n// other handlers. Its purpose is to tell the caller that this coalescer should no longer be used.\n\nexport default function promiseCoalescer(finallyFn) {\n  let currentPromise;\n  let currentCancelFn;\n  let finalResolve;\n  let finalReject;\n\n  const coalescer = {};\n\n  coalescer.addPromise = (p, cancelFn) => {\n    currentPromise = p;\n    currentCancelFn && currentCancelFn();\n    currentCancelFn = cancelFn;\n\n    p.then(\n      result => {\n        if (currentPromise === p) {\n          finalResolve(result);\n          finallyFn && finallyFn();\n        }\n      },\n      error => {\n        if (currentPromise === p) {\n          finalReject(error);\n          finallyFn && finallyFn();\n        }\n      }\n    );\n  };\n\n  coalescer.resultPromise = new Promise((resolve, reject) => {\n    finalResolve = resolve;\n    finalReject = reject;\n  });\n\n  return coalescer;\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","import uuidv1 from 'uuid/v1';\n\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\n// Transforms the user object if necessary to make sure it has a valid key.\n// 1. If a key is present, but is not a string, change it to a string.\n// 2. If no key is present, and \"anonymous\" is true, use a UUID as a key. This is cached in local\n// storage if possible.\n// 3. If there is no key (or no user object), return an error.\n\nconst ldUserIdKey = 'ld:$anonUserId';\n\nexport default function UserValidator(localStorageProvider, logger) {\n  function getCachedUserId() {\n    if (localStorageProvider) {\n      return localStorageProvider.get(ldUserIdKey).catch(() => null);\n      // Not logging errors here, because if local storage fails for the get, it will presumably fail for the set,\n      // so we will end up logging an error in setCachedUserId anyway.\n    }\n    return Promise.resolve(null);\n  }\n\n  function setCachedUserId(id) {\n    if (localStorageProvider) {\n      return localStorageProvider.set(ldUserIdKey, id).catch(() => {\n        logger.warn(messages.localStorageUnavailableForUserId());\n      });\n    }\n    return Promise.resolve();\n  }\n\n  const ret = {};\n\n  // Validates the user, returning a Promise that resolves to the validated user, or rejects if there is an error.\n  ret.validateUser = user => {\n    if (!user) {\n      return Promise.reject(new errors.LDInvalidUserError(messages.userNotSpecified()));\n    }\n\n    const userOut = utils.clone(user);\n    if (userOut.key !== null && userOut.key !== undefined) {\n      userOut.key = userOut.key.toString();\n      return Promise.resolve(userOut);\n      return;\n    }\n    if (userOut.anonymous) {\n      return getCachedUserId().then(cachedId => {\n        if (cachedId) {\n          userOut.key = cachedId;\n          return userOut;\n        } else {\n          const id = uuidv1();\n          userOut.key = id;\n          return setCachedUserId(id).then(() => userOut);\n        }\n      });\n    } else {\n      return Promise.reject(new errors.LDInvalidUserError(messages.invalidUser()));\n    }\n  };\n\n  return ret;\n}\n","// Default implementation of our internal logging interface, which writes messages to the console.\n// If no minimum level is specified, all messages will be logged. Setting the level to \"none\"\n// disables all logging.\n\nexport default function createConsoleLogger(level) {\n  const allLevels = ['debug', 'info', 'warn', 'error'];\n  let minLevelIndex = 0;\n  if (level) {\n    if (level === 'none') {\n      minLevelIndex = 100;\n    } else {\n      minLevelIndex = allLevels.indexOf(level);\n    }\n  }\n\n  const logger = {};\n\n  function log(levelIndex, outputFn, msg) {\n    if (levelIndex >= minLevelIndex) {\n      outputFn(msg);\n    }\n  }\n\n  logger.debug = msg => log(0, console.log, msg);\n  logger.info = msg => log(1, console.info, msg);\n  logger.warn = msg => log(2, console.warn, msg);\n  logger.error = msg => log(3, console.error, msg);\n\n  return logger;\n}\n","import EventProcessor from './EventProcessor';\nimport EventEmitter from './EventEmitter';\nimport Store from './Store';\nimport Stream from './Stream';\nimport Requestor from './Requestor';\nimport Identity from './Identity';\nimport UserValidator from './UserValidator';\nimport * as configuration from './configuration';\nimport createConsoleLogger from './consoleLogger';\nimport * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\n\nconst readyEvent = 'ready';\nconst successEvent = 'initialized';\nconst failedEvent = 'failed';\nconst changeEvent = 'change';\nconst internalChangeEvent = 'internal-change';\n\n// This is called by the per-platform initialize functions to create the base client object that we\n// may also extend with additional behavior. It returns an object with these properties:\n//   client: the actual client object\n//   options: the configuration (after any appropriate defaults have been applied)\n// If we need to give the platform-specific clients access to any internals here, we should add those\n// as properties of the return object, not public properties of the client.\n//\n// For definitions of the API in the platform object, see stubPlatform.js in the test code.\n\nexport function initialize(env, user, specifiedOptions, platform, extraDefaults) {\n  const logger = createLogger();\n  const emitter = EventEmitter(logger);\n  const options = configuration.validate(specifiedOptions, emitter, extraDefaults, logger);\n  const hash = options.hash;\n  const sendEvents = options.sendEvents;\n  let environment = env;\n  const stream = Stream(platform, options, environment, hash);\n  const events = options.eventProcessor || EventProcessor(platform, options, environment, logger, emitter);\n  const requestor = Requestor(platform, options, environment, logger);\n  const seenRequests = {};\n  let flags = {};\n  let useLocalStorage;\n  let streamActive;\n  let streamForcedState = options.streaming;\n  let subscribedToChangeEvents;\n  let inited = false;\n  let closed = false;\n  let firstEvent = true;\n\n  // The \"stateProvider\" object is used in the Electron SDK, to allow one client instance to take partial\n  // control of another. If present, it has the following contract:\n  // - getInitialState() returns the initial client state if it is already available. The state is an\n  //   object whose properties are \"environment\", \"user\", and \"flags\".\n  // - on(\"init\", listener) triggers an event when the initial client state becomes available, passing\n  //   the state object to the listener.\n  // - on(\"update\", listener) triggers an event when flag values change and/or the current user changes.\n  //   The parameter is an object that *may* contain \"user\" and/or \"flags\".\n  // - enqueueEvent(event) accepts an analytics event object and returns true if the stateProvider will\n  //   be responsible for delivering it, or false if we still should deliver it ourselves.\n  const stateProvider = options.stateProvider;\n\n  const ident = Identity(null, sendIdentifyEvent);\n  const userValidator = UserValidator(platform.localStorage, logger);\n  let store;\n  if (platform.localStorage) {\n    store = new Store(platform.localStorage, environment, hash, ident, logger);\n  }\n\n  function createLogger() {\n    if (specifiedOptions && specifiedOptions.logger) {\n      return specifiedOptions.logger;\n    }\n    return (extraDefaults && extraDefaults.logger) || createConsoleLogger('warn');\n  }\n\n  function readFlagsFromBootstrap(data) {\n    // If the bootstrap data came from an older server-side SDK, we'll have just a map of keys to values.\n    // Newer SDKs that have an allFlagsState method will provide an extra \"$flagsState\" key that contains\n    // the rest of the metadata we want. We do it this way for backward compatibility with older JS SDKs.\n    const keys = Object.keys(data);\n    const metadataKey = '$flagsState';\n    const validKey = '$valid';\n    const metadata = data[metadataKey];\n    if (!metadata && keys.length) {\n      logger.warn(messages.bootstrapOldFormat());\n    }\n    if (data[validKey] === false) {\n      logger.warn(messages.bootstrapInvalid());\n    }\n    const ret = {};\n    keys.forEach(key => {\n      if (key !== metadataKey && key !== validKey) {\n        let flag = { value: data[key] };\n        if (metadata && metadata[key]) {\n          flag = utils.extend(flag, metadata[key]);\n        } else {\n          flag.version = 0;\n        }\n        ret[key] = flag;\n      }\n    });\n    return ret;\n  }\n\n  function shouldEnqueueEvent() {\n    return sendEvents && !closed && !platform.isDoNotTrack();\n  }\n\n  function enqueueEvent(event) {\n    if (!environment) {\n      // We're in paired mode and haven't been initialized with an environment or user yet\n      return;\n    }\n    if (stateProvider && stateProvider.enqueueEvent && stateProvider.enqueueEvent(event)) {\n      return; // it'll be handled elsewhere\n    }\n    if (!event.user) {\n      if (firstEvent) {\n        logger.warn(messages.eventWithoutUser());\n        firstEvent = false;\n      }\n      return;\n    }\n    firstEvent = false;\n    if (shouldEnqueueEvent()) {\n      logger.debug(messages.debugEnqueueingEvent(event.kind));\n      events.enqueue(event);\n    }\n  }\n\n  function sendIdentifyEvent(user) {\n    if (stateProvider) {\n      // In paired mode, the other client is responsible for sending identify events\n      return;\n    }\n    if (user) {\n      enqueueEvent({\n        kind: 'identify',\n        key: user.key,\n        user: user,\n        creationDate: new Date().getTime(),\n      });\n    }\n  }\n\n  function sendFlagEvent(key, detail, defaultValue) {\n    const user = ident.getUser();\n    const now = new Date();\n    const value = detail ? detail.value : null;\n    if (!options.allowFrequentDuplicateEvents) {\n      const cacheKey = JSON.stringify(value) + (user && user.key ? user.key : '') + key; // see below\n      const cached = seenRequests[cacheKey];\n      // cache TTL is five minutes\n      if (cached && now - cached < 300000) {\n        return;\n      }\n      seenRequests[cacheKey] = now;\n    }\n\n    const event = {\n      kind: 'feature',\n      key: key,\n      user: user,\n      value: value,\n      variation: detail ? detail.variationIndex : null,\n      default: defaultValue,\n      creationDate: now.getTime(),\n      reason: detail ? detail.reason : null,\n    };\n    const flag = flags[key];\n    if (flag) {\n      event.version = flag.flagVersion ? flag.flagVersion : flag.version;\n      event.trackEvents = flag.trackEvents;\n      event.debugEventsUntilDate = flag.debugEventsUntilDate;\n    }\n\n    enqueueEvent(event);\n  }\n\n  function identify(user, hash, onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve({}), onDone);\n    }\n    if (stateProvider) {\n      // We're being controlled by another client instance, so only that instance is allowed to change the user\n      logger.warn(messages.identifyDisabled());\n      return utils.wrapPromiseCallback(Promise.resolve(utils.transformVersionedValuesToValues(flags)), onDone);\n    }\n    const clearFirst = useLocalStorage && store ? store.clearFlags() : Promise.resolve();\n    return utils.wrapPromiseCallback(\n      clearFirst\n        .then(() => userValidator.validateUser(user))\n        .then(realUser => ident.setUser(realUser))\n        .then(() => requestor.fetchFlagSettings(ident.getUser(), hash))\n        .then(requestedFlags => {\n          const flagValueMap = utils.transformVersionedValuesToValues(requestedFlags);\n          if (requestedFlags) {\n            return replaceAllFlags(requestedFlags).then(() => flagValueMap);\n          } else {\n            return flagValueMap;\n          }\n        })\n        .then(flagValueMap => {\n          if (streamActive) {\n            connectStream();\n          }\n          return flagValueMap;\n        })\n        .catch(err => {\n          emitter.maybeReportError(err);\n          return Promise.reject(err);\n        }),\n      onDone\n    );\n  }\n\n  function getUser() {\n    return ident.getUser();\n  }\n\n  function flush(onDone) {\n    return utils.wrapPromiseCallback(sendEvents ? events.flush() : Promise.resolve(), onDone);\n  }\n\n  function variation(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true).value;\n  }\n\n  function variationDetail(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true);\n  }\n\n  function variationDetailInternal(key, defaultValue, sendEvent) {\n    let detail;\n\n    if (flags && flags.hasOwnProperty(key) && flags[key] && !flags[key].deleted) {\n      const flag = flags[key];\n      detail = getFlagDetail(flag);\n      if (flag.value === null || flag.value === undefined) {\n        detail.value = defaultValue;\n      }\n    } else {\n      detail = { value: defaultValue, variationIndex: null, reason: { kind: 'ERROR', errorKind: 'FLAG_NOT_FOUND' } };\n    }\n\n    if (sendEvent) {\n      sendFlagEvent(key, detail, defaultValue);\n    }\n\n    return detail;\n  }\n\n  function getFlagDetail(flag) {\n    return {\n      value: flag.value,\n      variationIndex: flag.variation === undefined ? null : flag.variation,\n      reason: flag.reason || null,\n    };\n    // Note, the logic above ensures that variationIndex and reason will always be null rather than\n    // undefined if we don't have values for them. That's just to avoid subtle errors that depend on\n    // whether an object was JSON-encoded with null properties omitted or not.\n  }\n\n  function allFlags() {\n    const results = {};\n\n    if (!flags) {\n      return results;\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key)) {\n        results[key] = variationDetailInternal(key, null, !options.sendEventsOnlyForVariation).value;\n      }\n    }\n\n    return results;\n  }\n\n  function track(key, data) {\n    if (typeof key !== 'string') {\n      emitter.maybeReportError(new errors.LDInvalidEventKeyError(messages.unknownCustomEventKey(key)));\n      return;\n    }\n\n    if (platform.customEventFilter && !platform.customEventFilter(key)) {\n      logger.warn(messages.unknownCustomEventKey(key));\n    }\n\n    enqueueEvent({\n      kind: 'custom',\n      key: key,\n      data: data,\n      user: ident.getUser(),\n      url: platform.getCurrentUrl(),\n      creationDate: new Date().getTime(),\n    });\n  }\n\n  function connectStream() {\n    streamActive = true;\n    if (!ident.getUser()) {\n      return;\n    }\n    stream.connect(ident.getUser(), {\n      ping: function() {\n        logger.debug(messages.debugStreamPing());\n        requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n          if (err) {\n            emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n          }\n          replaceAllFlags(settings); // don't wait for this Promise to be resolved\n        });\n      },\n      put: function(e) {\n        const data = JSON.parse(e.data);\n        logger.debug(messages.debugStreamPut());\n        replaceAllFlags(data); // don't wait for this Promise to be resolved\n      },\n      patch: function(e) {\n        const data = JSON.parse(e.data);\n        // If both the flag and the patch have a version property, then the patch version must be\n        // greater than the flag version for us to accept the patch.  If either one has no version\n        // then the patch always succeeds.\n        const oldFlag = flags[data.key];\n        if (!oldFlag || !oldFlag.version || !data.version || oldFlag.version < data.version) {\n          logger.debug(messages.debugStreamPatch(data.key));\n          const mods = {};\n          const newFlag = utils.extend({}, data);\n          delete newFlag['key'];\n          flags[data.key] = newFlag;\n          const newDetail = getFlagDetail(newFlag);\n          if (oldFlag) {\n            mods[data.key] = { previous: oldFlag.value, current: newDetail };\n          } else {\n            mods[data.key] = { current: newDetail };\n          }\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n        } else {\n          logger.debug(messages.debugStreamPatchIgnored(data.key));\n        }\n      },\n      delete: function(e) {\n        const data = JSON.parse(e.data);\n        if (!flags[data.key] || flags[data.key].version < data.version) {\n          logger.debug(messages.debugStreamDelete(data.key));\n          const mods = {};\n          if (flags[data.key] && !flags[data.key].deleted) {\n            mods[data.key] = { previous: flags[data.key].value };\n          }\n          flags[data.key] = { version: data.version, deleted: true };\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n        } else {\n          logger.debug(messages.debugStreamDeleteIgnored(data.key));\n        }\n      },\n    });\n  }\n\n  function disconnectStream() {\n    if (streamActive) {\n      stream.disconnect();\n      streamActive = false;\n    }\n  }\n\n  // Returns a Promise which will be resolved when we have completely updated the internal flags state,\n  // dispatched all change events, and updated local storage if appropriate. This Promise is guaranteed\n  // never to have an unhandled rejection.\n  function replaceAllFlags(newFlags) {\n    const changes = {};\n\n    if (!newFlags) {\n      return Promise.resolve();\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key) && flags[key]) {\n        if (newFlags[key] && !utils.deepEquals(newFlags[key].value, flags[key].value)) {\n          changes[key] = { previous: flags[key].value, current: getFlagDetail(newFlags[key]) };\n        } else if (!newFlags[key] || newFlags[key].deleted) {\n          changes[key] = { previous: flags[key].value };\n        }\n      }\n    }\n    for (const key in newFlags) {\n      if (newFlags.hasOwnProperty(key) && newFlags[key] && (!flags[key] || flags[key].deleted)) {\n        changes[key] = { current: getFlagDetail(newFlags[key]) };\n      }\n    }\n\n    flags = newFlags;\n    return handleFlagChanges(changes).catch(() => {}); // swallow any exceptions from this Promise\n  }\n\n  // Returns a Promise which will be resolved when we have dispatched all change events and updated\n  // local storage if appropriate.\n  function handleFlagChanges(changes) {\n    const keys = Object.keys(changes);\n\n    if (keys.length > 0) {\n      const changeEventParams = {};\n      keys.forEach(key => {\n        const current = changes[key].current;\n        const value = current ? current.value : undefined;\n        const previous = changes[key].previous;\n        emitter.emit(changeEvent + ':' + key, value, previous);\n        changeEventParams[key] = current ? { current: value, previous: previous } : { previous: previous };\n      });\n\n      emitter.emit(changeEvent, changeEventParams);\n      emitter.emit(internalChangeEvent, flags);\n\n      // By default, we send feature evaluation events whenever we have received new flag values -\n      // the client has in effect evaluated these flags just by receiving them. This can be suppressed\n      // by setting \"sendEventsOnlyForVariation\". Also, if we have a stateProvider, we don't send these\n      // events because we assume they have already been sent by the other client that gave us the flags\n      // (when it received them in the first place).\n      if (!options.sendEventsOnlyForVariation && !stateProvider) {\n        keys.forEach(key => {\n          sendFlagEvent(key, changes[key].current);\n        });\n      }\n    }\n\n    if (useLocalStorage && store) {\n      return store.saveFlags(flags).catch(() => null); // disregard errors\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function on(event, handler, context) {\n    if (isChangeEventKey(event)) {\n      subscribedToChangeEvents = true;\n      if (inited) {\n        updateStreamingState();\n      }\n      emitter.on(event, handler, context);\n    } else {\n      emitter.on(...arguments);\n    }\n  }\n\n  function off(event) {\n    emitter.off(...arguments);\n    if (isChangeEventKey(event)) {\n      let haveListeners = false;\n      emitter.getEvents().forEach(key => {\n        if (isChangeEventKey(key) && emitter.getEventListenerCount(key) > 0) {\n          haveListeners = true;\n        }\n      });\n      if (!haveListeners) {\n        subscribedToChangeEvents = false;\n        if (streamActive && streamForcedState === undefined) {\n          disconnectStream();\n        }\n      }\n    }\n  }\n\n  function setStreaming(state) {\n    const newState = state === null ? undefined : state;\n    if (newState !== streamForcedState) {\n      streamForcedState = newState;\n      updateStreamingState();\n    }\n  }\n\n  function updateStreamingState() {\n    const shouldBeStreaming = streamForcedState || (subscribedToChangeEvents && streamForcedState === undefined);\n    if (shouldBeStreaming && !streamActive) {\n      connectStream();\n    } else if (!shouldBeStreaming && streamActive) {\n      disconnectStream();\n    }\n  }\n\n  function isChangeEventKey(event) {\n    return event === changeEvent || event.substr(0, changeEvent.length + 1) === changeEvent + ':';\n  }\n\n  const readyPromise = new Promise(resolve => {\n    const onReady = emitter.on(readyEvent, () => {\n      emitter.off(readyEvent, onReady);\n      resolve();\n    });\n  });\n\n  const initPromise = new Promise((resolve, reject) => {\n    const onSuccess = emitter.on(successEvent, () => {\n      emitter.off(successEvent, onSuccess);\n      resolve();\n    });\n    const onFailure = emitter.on(failedEvent, err => {\n      emitter.off(failedEvent, onFailure);\n      reject(err);\n    });\n  });\n\n  if (typeof options.bootstrap === 'string' && options.bootstrap.toUpperCase() === 'LOCALSTORAGE') {\n    if (store) {\n      useLocalStorage = true;\n    } else {\n      logger.warn(messages.localStorageUnavailable());\n    }\n  }\n\n  if (stateProvider) {\n    // The stateProvider option is used in the Electron SDK, to allow a client instance in the main process\n    // to control another client instance (i.e. this one) in the renderer process. We can't predict which\n    // one will start up first, so the initial state may already be available for us or we may have to wait\n    // to receive it.\n    const state = stateProvider.getInitialState();\n    if (state) {\n      initFromStateProvider(state);\n    } else {\n      stateProvider.on('init', initFromStateProvider);\n    }\n    stateProvider.on('update', updateFromStateProvider);\n  } else {\n    finishInit().catch(err => emitter.maybeReportError(err));\n  }\n\n  function finishInit() {\n    if (!env) {\n      return Promise.reject(new errors.LDInvalidEnvironmentIdError(messages.environmentNotSpecified()));\n    }\n    return userValidator.validateUser(user).then(realUser => {\n      ident.setUser(realUser);\n      if (typeof options.bootstrap === 'object') {\n        flags = readFlagsFromBootstrap(options.bootstrap);\n        return signalSuccessfulInit();\n      } else if (useLocalStorage) {\n        return finishInitWithLocalStorage();\n      } else {\n        return finishInitWithPolling();\n      }\n    });\n  }\n\n  function finishInitWithLocalStorage() {\n    return store\n      .loadFlags()\n      .catch(() => null) // treat an error the same as if no flags were available\n      .then(storedFlags => {\n        if (storedFlags === null || storedFlags === undefined) {\n          flags = {};\n          return requestor\n            .fetchFlagSettings(ident.getUser(), hash)\n            .then(requestedFlags => replaceAllFlags(requestedFlags || {}))\n            .then(signalSuccessfulInit)\n            .catch(err => {\n              const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n              signalFailedInit(initErr);\n            });\n        } else {\n          // We're reading the flags from local storage. Signal that we're ready,\n          // then update localStorage for the next page load. We won't signal changes or update\n          // the in-memory flags unless you subscribe for changes\n          flags = storedFlags;\n          utils.onNextTick(signalSuccessfulInit);\n\n          return requestor\n            .fetchFlagSettings(ident.getUser(), hash)\n            .then(requestedFlags => replaceAllFlags(requestedFlags))\n            .catch(err => emitter.maybeReportError(err));\n        }\n      });\n  }\n\n  function finishInitWithPolling() {\n    return requestor\n      .fetchFlagSettings(ident.getUser(), hash)\n      .then(requestedFlags => {\n        flags = requestedFlags || {};\n        // Note, we don't need to call updateSettings here because local storage and change events are not relevant\n        signalSuccessfulInit();\n      })\n      .catch(err => {\n        flags = {};\n        signalFailedInit(err);\n      });\n  }\n\n  function initFromStateProvider(state) {\n    environment = state.environment;\n    ident.setUser(state.user);\n    flags = state.flags;\n    utils.onNextTick(signalSuccessfulInit);\n  }\n\n  function updateFromStateProvider(state) {\n    if (state.user) {\n      ident.setUser(state.user);\n    }\n    if (state.flags) {\n      replaceAllFlags(state.flags); // don't wait for this Promise to be resolved\n    }\n  }\n\n  function signalSuccessfulInit() {\n    logger.info(messages.clientInitialized());\n    inited = true;\n    updateStreamingState();\n    emitter.emit(readyEvent);\n    emitter.emit(successEvent); // allows initPromise to distinguish between success and failure\n  }\n\n  function signalFailedInit(err) {\n    emitter.maybeReportError(err);\n    emitter.emit(failedEvent, err);\n    emitter.emit(readyEvent); // for backward compatibility, this event happens even on failure\n  }\n\n  function start() {\n    if (sendEvents) {\n      events.start();\n    }\n  }\n\n  function close(onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve(), onDone);\n    }\n    const finishClose = () => {\n      closed = true;\n      flags = {};\n    };\n    const p = Promise.resolve()\n      .then(() => {\n        disconnectStream();\n        if (sendEvents) {\n          events.stop();\n          return events.flush();\n        }\n      })\n      .then(finishClose)\n      .catch(finishClose);\n    return utils.wrapPromiseCallback(p, onDone);\n  }\n\n  function getFlagsInternal() {\n    // used by Electron integration\n    return flags;\n  }\n\n  const client = {\n    waitForInitialization: () => initPromise,\n    waitUntilReady: () => readyPromise,\n    identify: identify,\n    getUser: getUser,\n    variation: variation,\n    variationDetail: variationDetail,\n    track: track,\n    on: on,\n    off: off,\n    setStreaming: setStreaming,\n    flush: flush,\n    allFlags: allFlags,\n    close: close,\n  };\n\n  return {\n    client: client, // The client object containing all public methods.\n    options: options, // The validated configuration object, including all defaults.\n    emitter: emitter, // The event emitter which can be used to log errors or trigger events.\n    ident: ident, // The Identity object that manages the current user.\n    logger: logger, // The logging abstraction.\n    requestor: requestor, // The Requestor object.\n    start: start, // Starts the client once the environment is ready.\n    enqueueEvent: enqueueEvent, // Puts an analytics event in the queue, if event sending is enabled.\n    getFlagsInternal: getFlagsInternal, // Returns flag data structure with all details.\n    internalChangeEventName: internalChangeEvent, // This event is triggered whenever we have new flag state.\n  };\n}\n\nexport const version = VERSION;\nexport { createConsoleLogger };\nexport { errors };\nexport { messages };\nexport { utils };\n","import * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\nexport function validate(options, emitter, extraDefaults, logger) {\n  const baseDefaults = {\n    baseUrl: 'https://app.launchdarkly.com',\n    streamUrl: 'https://clientstream.launchdarkly.com',\n    eventsUrl: 'https://events.launchdarkly.com',\n    sendEvents: true,\n    sendLDHeaders: true,\n    inlineUsersInEvents: false,\n    allowFrequentDuplicateEvents: false,\n    sendEventsOnlyForVariation: false,\n    useReport: false,\n    evaluationReasons: false,\n    flushInterval: 2000,\n    samplingInterval: 0,\n    streamReconnectDelay: 1000,\n    allAttributesPrivate: false,\n    privateAttributeNames: [],\n  };\n  const defaults = utils.extend({}, baseDefaults, extraDefaults);\n\n  const deprecatedOptions = {\n    // eslint-disable-next-line camelcase\n    all_attributes_private: 'allAttributesPrivate',\n    // eslint-disable-next-line camelcase\n    private_attribute_names: 'privateAttributeNames',\n  };\n\n  function checkDeprecatedOptions(config) {\n    const opts = config;\n    Object.keys(deprecatedOptions).forEach(oldName => {\n      if (opts[oldName] !== undefined) {\n        const newName = deprecatedOptions[oldName];\n        logger.warn(messages.deprecated(oldName, newName));\n        if (opts[newName] === undefined) {\n          opts[newName] = opts[oldName];\n        }\n        delete opts[oldName];\n      }\n    });\n  }\n\n  function applyDefaults(config, defaults) {\n    // This works differently from utils.extend() in that it *will* override a default value\n    // if the provided value is explicitly set to null. This provides backward compatibility\n    // since in the past we only used the provided values if they were truthy.\n    const ret = utils.extend({}, config);\n    Object.keys(defaults).forEach(name => {\n      if (ret[name] === undefined || ret[name] === null) {\n        ret[name] = defaults[name];\n      }\n    });\n    return ret;\n  }\n\n  function reportArgumentError(message) {\n    utils.onNextTick(() => {\n      emitter && emitter.maybeReportError(new errors.LDInvalidArgumentError(message));\n    });\n  }\n\n  let config = utils.extend({}, options || {});\n\n  checkDeprecatedOptions(config);\n\n  config = applyDefaults(config, defaults);\n\n  if (isNaN(config.flushInterval) || config.flushInterval < 2000) {\n    config.flushInterval = 2000;\n    reportArgumentError('Invalid flush interval configured. Must be an integer >= 2000 (milliseconds).');\n  }\n  if (isNaN(config.samplingInterval) || config.samplingInterval < 0) {\n    config.samplingInterval = 0;\n    reportArgumentError('Invalid sampling interval configured. Sampling interval must be an integer >= 0.');\n  }\n\n  return config;\n}\n","import { base64URLEncode } from './utils';\n\n// The underlying event source implementation is abstracted via the platform object, which should\n// have these three properties:\n// eventSourceFactory(): a function that takes a URL and optional request body and returns an object\n//   with the same methods as the regular HTML5 EventSource object. Passing a body parameter means\n//   that the request should use REPORT instead of GET.\n// eventSourceIsActive(): a function that takes an EventSource-compatible object and returns true if\n//   it is in an active state (connected or connecting).\n// eventSourceAllowsReport: true if REPORT is supported.\n\nexport default function Stream(platform, config, environment, hash) {\n  const baseUrl = config.streamUrl;\n  const stream = {};\n  const evalUrlPrefix = baseUrl + '/eval/' + environment;\n  const useReport = config.useReport;\n  const withReasons = config.evaluationReasons;\n  const streamReconnectDelay = config.streamReconnectDelay;\n  let es = null;\n  let reconnectTimeoutReference = null;\n  let user = null;\n  let handlers = null;\n\n  stream.connect = function(newUser, newHandlers) {\n    user = newUser;\n    handlers = newHandlers;\n    tryConnect();\n  };\n\n  stream.disconnect = function() {\n    clearTimeout(reconnectTimeoutReference);\n    reconnectTimeoutReference = null;\n    closeConnection();\n  };\n\n  stream.isConnected = function() {\n    return es && platform.eventSourceIsActive && platform.eventSourceIsActive(es);\n  };\n\n  function reconnect() {\n    closeConnection();\n    tryConnect(streamReconnectDelay);\n  }\n\n  function tryConnect(delay) {\n    if (!reconnectTimeoutReference) {\n      if (delay) {\n        reconnectTimeoutReference = setTimeout(openConnection, delay);\n      } else {\n        openConnection();\n      }\n    }\n  }\n\n  function openConnection() {\n    let url;\n    let query = '';\n    const options = {};\n    if (platform.eventSourceFactory) {\n      if (hash !== null && hash !== undefined) {\n        query = 'h=' + hash;\n      }\n      if (useReport) {\n        if (platform.eventSourceAllowsReport) {\n          url = evalUrlPrefix;\n          options.method = 'REPORT';\n          options.headers = { 'Content-Type': 'application/json' };\n          options.body = JSON.stringify(user);\n        } else {\n          // if we can't do REPORT, fall back to the old ping-based stream\n          url = baseUrl + '/ping/' + environment;\n          query = '';\n        }\n      } else {\n        url = evalUrlPrefix + '/' + base64URLEncode(JSON.stringify(user));\n      }\n      if (withReasons) {\n        query = query + (query ? '&' : '') + 'withReasons=true';\n      }\n      url = url + (query ? '?' : '') + query;\n\n      closeConnection();\n      es = platform.eventSourceFactory(url, options);\n      for (const key in handlers) {\n        if (handlers.hasOwnProperty(key)) {\n          es.addEventListener(key, handlers[key]);\n        }\n      }\n\n      es.onerror = reconnect;\n    }\n  }\n\n  function closeConnection() {\n    if (es) {\n      es.close();\n      es = null;\n    }\n  }\n\n  return stream;\n}\n","import * as utils from './utils';\n\nexport default function Identity(initialUser, onChange) {\n  const ident = {};\n  let user;\n\n  ident.setUser = function(u) {\n    user = utils.sanitizeUser(u);\n    if (user && onChange) {\n      onChange(utils.clone(user));\n    }\n  };\n\n  ident.getUser = function() {\n    return user ? utils.clone(user) : null;\n  };\n\n  if (initialUser) {\n    ident.setUser(initialUser);\n  }\n\n  return ident;\n}\n","import * as messages from './messages';\nimport * as utils from './utils';\n\n// The localStorageProvider is provided by the platform object. It should have the following\n// methods, each of which should return a Promise:\n// - get(key): Gets the string value, if any, for the given key\n// - set(key, value): Stores a string value for the given key\n// - remove(key): Removes the given key\nexport default function Store(localStorageProvider, environment, hash, ident, logger) {\n  const store = {};\n\n  function getFlagsKey() {\n    let key = '';\n    const user = ident.getUser();\n    if (user) {\n      key = hash || utils.btoa(JSON.stringify(user));\n    }\n    return 'ld:' + environment + ':' + key;\n  }\n\n  // Returns a Promise which will be resolved with a parsed JSON value if a stored value was available,\n  // resolved with null if there was no value, or rejected if storage was not available.\n  store.loadFlags = () =>\n    localStorageProvider\n      .get(getFlagsKey())\n      .then(dataStr => {\n        if (dataStr === null || dataStr === undefined) {\n          return null;\n        }\n        try {\n          let data = JSON.parse(dataStr);\n          if (data) {\n            const schema = data.$schema;\n            if (schema === undefined || schema < 1) {\n              data = utils.transformValuesToVersionedValues(data);\n            } else {\n              delete data['$schema'];\n            }\n          }\n          return data;\n        } catch (ex) {\n          return store.clearFlags().then(() => Promise.reject(ex));\n        }\n      })\n      .catch(err => {\n        logger.warn(messages.localStorageUnavailable());\n        return Promise.reject(err);\n      });\n\n  // Returns a Promise which will be resolved with no value if successful, or rejected if storage\n  // was not available.\n  store.saveFlags = flags => {\n    const data = utils.extend({}, flags, { $schema: 1 });\n    return localStorageProvider.set(getFlagsKey(), JSON.stringify(data)).catch(err => {\n      logger.warn(messages.localStorageUnavailable());\n      return Promise.reject(err);\n    });\n  };\n\n  // Returns a Promise which will be resolved with no value if successful, or rejected if storage\n  // was not available.\n  store.clearFlags = () =>\n    localStorageProvider.clear(getFlagsKey()).catch(err => {\n      logger.warn(messages.localStorageUnavailable());\n      return Promise.reject(err);\n    });\n\n  return store;\n}\n"],"names":["createCustomError","name","CustomError","message","code","captureStackTrace","Error","this","constructor","prototype","LDUnexpectedResponseError","LDInvalidEnvironmentIdError","LDInvalidUserError","LDInvalidEventKeyError","LDInvalidArgumentError","LDFlagFetchError","isHttpErrorRecoverable","status","uint8","tmp","len","length","extraBytes","parts","i","len2","push","encodeChunk","lookup","join","revLookup","charCodeAt","start","end","num","output","isArray","Array","keyList","Object","keys","hasProp","hasOwnProperty","equal","a","b","key","arrA","arrB","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","call","userAttrsToStringify","btoa","s","escaped","unescape","encodeURIComponent","base64","stringToBytes","base64URLEncode","replace","clone","obj","JSON","parse","stringify","deepEquals","fastDeepEqual","onNextTick","cb","wrapPromiseCallback","promise","callback","ret","then","value","Promise","reject","error","undefined","transformValuesToVersionedValues","flags","version","transformVersionedValuesToValues","flagsState","chunkUserEventsForUrl","maxLength","events","allEvents","slice","allChunks","remainingSpace","chunk","event","shift","unshift","getLDUserAgentString","platform","userAgent","getLDHeaders","extend","objects","reduce","acc","sanitizeUser","user","newUser","attr","assign","String","MAX_URL_LENGTH","EventSender","eventsUrl","environmentId","imageCreator","postUrl","imageUrl","sender","loadUrlUsingImage","src","window","Image","sendChunk","usePost","createImage","jsonBody","doPostRequest","canRetry","headers","utils","httpRequest","result","errors","dateStr","header","time","serverTime","getResponseInfo","catch","resolve","sendEvents","canPost","httpAllowsPost","chunks","results","all","UserFilter","config","filter","allAttributesPrivate","privateAttributeNames","ignoreAttrs","custom","anonymous","allowedTopLevelAttrs","filterUser","userPrivateAttrs","filterAttrs","props","isAttributeAllowed","indexOf","isPrivateAttr","filteredProps","removedAttrs","customResult","removedAttrNames","sort","privateAttrs","clientInitialized","docLink","eventWithoutUser","localStorageUnavailable","localStorageUnavailableForUserId","networkError","e","unknownCustomEventKey","environmentNotFound","environmentNotSpecified","errorFetchingFlags","err","userNotSpecified","invalidUser","bootstrapOldFormat","bootstrapInvalid","deprecated","oldName","newName","httpErrorMessage","context","retryMessage","httpUnavailable","identifyDisabled","debugPolling","url","debugStreamPing","debugStreamPut","debugStreamPatch","debugStreamPatchIgnored","debugStreamDelete","debugStreamDeleteIgnored","debugEnqueueingEvent","kind","debugPostingEvents","count","EventProcessor","options","logger","es","startDate","endDate","counters","emitter","processor","eventSender","summarizer","summarizeEvent","counterKey","variation","counterVal","default","creationDate","getSummary","flagsOut","empty","c","flag","counterOut","unknown","clearSummary","userFilter","inlineUsers","inlineUsersInEvents","samplingInterval","flushInterval","queue","lastKnownPastTime","disabled","flushTimer","shouldSampleEvent","Math","floor","random","enqueue","addFullEvent","addDebugEvent","trackEvents","debugEventsUntilDate","userKey","makeOutputEvent","debugEvent","flush","eventsToSend","summary","debug","messages","responseInfo","maybeReportError","setTimeout","flushTick","stop","EventEmitter","on","handler","concat","off","emit","apply","arguments","getEvents","getEventListenerCount","console","json","Requestor","environment","baseUrl","useReport","withReasons","evaluationReasons","sendLDHeaders","requestor","activeRequests","fetchJSON","endpoint","body","method","coalescer","finallyFn","currentPromise","currentCancelFn","finalResolve","finalReject","p","cancelFn","resultPromise","promiseCoalescer","req","lastIndexOf","statusText","getResponseError","addPromise","cancel","fetchFlagSettings","hash","data","query","fetchGoals","getRandomValues","crypto","bind","msCrypto","rnds8","Uint8Array","rnds","r","byteToHex","substr","_nodeId","_clockseq","buf","offset","bth","_lastMSecs","_lastNSecs","node","clockseq","seedBytes","rng","msecs","nsecs","dt","tl","tmh","n","bytesToUuid","ldUserIdKey","UserValidator","localStorageProvider","validateUser","userOut","get","cachedId","id","uuidv1","set","warn","setCachedUserId","createConsoleLogger","level","minLevelIndex","log","levelIndex","outputFn","msg","info","readyEvent","successEvent","failedEvent","changeEvent","internalChangeEvent","env","specifiedOptions","extraDefaults","defaults","deprecatedOptions","reportArgumentError","opts","forEach","applyDefaults","isNaN","configuration","stream","streamUrl","evalUrlPrefix","streamReconnectDelay","reconnectTimeoutReference","handlers","reconnect","tryConnect","delay","openConnection","eventSourceFactory","eventSourceAllowsReport","Content-Type","addEventListener","onerror","closeConnection","close","connect","newHandlers","disconnect","isConnected","eventSourceIsActive","Stream","eventProcessor","seenRequests","useLocalStorage","streamActive","streamForcedState","streaming","subscribedToChangeEvents","inited","closed","firstEvent","stateProvider","ident","initialUser","onChange","setUser","u","getUser","Identity","userValidator","localStorage","store","enqueueEvent","isDoNotTrack","sendFlagEvent","detail","defaultValue","now","allowFrequentDuplicateEvents","cacheKey","cached","variationIndex","reason","flagVersion","variationDetailInternal","sendEvent","deleted","getFlagDetail","errorKind","connectStream","settings","oldFlag","mods","newFlag","newDetail","previous","current","disconnectStream","replaceAllFlags","newFlags","changes","handleFlagChanges","changeEventParams","sendEventsOnlyForVariation","saveFlags","updateStreamingState","shouldBeStreaming","isChangeEventKey","getFlagsKey","loadFlags","dataStr","schema","$schema","ex","clearFlags","clear","readyPromise","onReady","initPromise","onSuccess","onFailure","bootstrap","toUpperCase","state","getInitialState","initFromStateProvider","realUser","_typeof","metadata","readFlagsFromBootstrap","signalSuccessfulInit","storedFlags","requestedFlags","initErr","signalFailedInit","onDone","flagValueMap","customEventFilter","getCurrentUrl","haveListeners","newState","finishClose"],"mappings":"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"}